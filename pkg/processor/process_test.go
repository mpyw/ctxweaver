package processor_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/mpyw/ctxweaver/pkg/config"
	"github.com/mpyw/ctxweaver/pkg/processor"
	"github.com/mpyw/ctxweaver/pkg/template"
)

// setupTestModule creates a temporary Go module for testing Process.
func setupTestModule(t *testing.T, files map[string]string) string {
	t.Helper()
	tmpDir := t.TempDir()

	// Create go.mod
	goMod := "module testmod\n\ngo 1.21\n"
	if err := os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte(goMod), 0o644); err != nil {
		t.Fatalf("failed to write go.mod: %v", err)
	}

	// Create test files
	for name, content := range files {
		path := filepath.Join(tmpDir, name)
		dir := filepath.Dir(path)
		if err := os.MkdirAll(dir, 0o755); err != nil {
			t.Fatalf("failed to create dir %s: %v", dir, err)
		}
		if err := os.WriteFile(path, []byte(content), 0o644); err != nil {
			t.Fatalf("failed to write %s: %v", name, err)
		}
	}

	return tmpDir
}

func TestProcess(t *testing.T) {
	tmpl, _ := template.Parse(`defer trace({{.Ctx}})`)
	registry, _ := config.NewCarrierRegistry()

	t.Run("basic insertion", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func trace(context.Context) {}

func Foo(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesProcessed != 1 {
			t.Errorf("FilesProcessed = %d, want 1", result.FilesProcessed)
		}
		if result.FilesModified != 1 {
			t.Errorf("FilesModified = %d, want 1", result.FilesModified)
		}

		// Verify file was modified
		content, _ := os.ReadFile(filepath.Join(tmpDir, "main.go"))
		if !strings.Contains(string(content), "defer trace(ctx)") {
			t.Errorf("expected defer statement not found in output:\n%s", content)
		}
	})

	t.Run("dry-run mode", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil, processor.WithDryRun(true))

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesModified != 1 {
			t.Errorf("FilesModified = %d, want 1", result.FilesModified)
		}

		// Verify file was NOT modified (dry-run)
		content, _ := os.ReadFile(filepath.Join(tmpDir, "main.go"))
		if strings.Contains(string(content), "defer trace(ctx)") {
			t.Errorf("file should not be modified in dry-run mode")
		}
	})

	t.Run("skip test files by default", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
			"main_test.go": `package main

import "context"

func TestBar(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		// Only main.go should be processed, not main_test.go
		if result.FilesProcessed != 1 {
			t.Errorf("FilesProcessed = %d, want 1", result.FilesProcessed)
		}
	})

	t.Run("process test files when enabled", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
			"main_test.go": `package main

import "context"

func TestBar(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil, processor.WithTest(true))

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		// Both files should be processed
		if result.FilesProcessed < 2 {
			t.Errorf("FilesProcessed = %d, want >= 2", result.FilesProcessed)
		}
	})

	t.Run("skip generated files", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"generated.go": `// Code generated by tool; DO NOT EDIT.

package main

import "context"

func Foo(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		// Generated file should be processed but not modified
		if result.FilesModified != 0 {
			t.Errorf("FilesModified = %d, want 0 (generated file should be skipped)", result.FilesModified)
		}
	})

	t.Run("remove mode", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func trace(context.Context) {}

func Foo(ctx context.Context) {
	defer trace(ctx)
}
`,
		})

		proc := processor.New(registry, tmpl, nil, processor.WithRemove(true))

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesModified != 1 {
			t.Errorf("FilesModified = %d, want 1", result.FilesModified)
		}

		// Verify defer was removed
		content, _ := os.ReadFile(filepath.Join(tmpDir, "main.go"))
		if strings.Contains(string(content), "defer trace(ctx)") {
			t.Errorf("defer statement should be removed:\n%s", content)
		}
	})

	t.Run("verbose mode", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil, processor.WithVerbose(true))

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesModified != 1 {
			t.Errorf("FilesModified = %d, want 1", result.FilesModified)
		}
	})

	t.Run("no matching functions", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

func Foo() {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesModified != 0 {
			t.Errorf("FilesModified = %d, want 0", result.FilesModified)
		}
	})

	t.Run("skip file with ctxweaver:skip directive", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `//ctxweaver:skip
package main

import "context"

func Foo(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesModified != 0 {
			t.Errorf("FilesModified = %d, want 0 (file has skip directive)", result.FilesModified)
		}
	})

	t.Run("multiple files", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"a.go": `package main

import "context"

func A(ctx context.Context) {
}
`,
			"b.go": `package main

import "context"

func B(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		if result.FilesProcessed != 2 {
			t.Errorf("FilesProcessed = %d, want 2", result.FilesProcessed)
		}
		if result.FilesModified != 2 {
			t.Errorf("FilesModified = %d, want 2", result.FilesModified)
		}
	})
}

func TestProcess_WithImports(t *testing.T) {
	tmpl, _ := template.Parse(`defer newrelic.FromContext({{.Ctx}}).StartSegment({{.FuncName | quote}}).End()`)
	registry, _ := config.NewCarrierRegistry()

	tmpDir := setupTestModule(t, map[string]string{
		"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
	})

	proc := processor.New(registry, tmpl, []string{"github.com/newrelic/go-agent/v3/newrelic"})

	oldWd, _ := os.Getwd()
	_ = os.Chdir(tmpDir)
	defer func() { _ = os.Chdir(oldWd) }()

	result, err := proc.Process([]string{"./..."})
	if err != nil {
		t.Fatalf("Process failed: %v", err)
	}

	if result.FilesModified != 1 {
		t.Errorf("FilesModified = %d, want 1", result.FilesModified)
	}

	// Verify import was added
	content, _ := os.ReadFile(filepath.Join(tmpDir, "main.go"))
	if !strings.Contains(string(content), "newrelic") {
		t.Errorf("expected newrelic import not found in output:\n%s", content)
	}
}

func TestShouldProcessFile(t *testing.T) {
	tmpl, _ := template.Parse(`defer trace({{.Ctx}})`)
	registry, _ := config.NewCarrierRegistry()

	t.Run("skip testdata directory", func(t *testing.T) {
		tmpDir := setupTestModule(t, map[string]string{
			"main.go": `package main

import "context"

func Foo(ctx context.Context) {
}
`,
			"testdata/fixture.go": `package testdata

import "context"

func Fixture(ctx context.Context) {
}
`,
		})

		proc := processor.New(registry, tmpl, nil)

		oldWd, _ := os.Getwd()
		_ = os.Chdir(tmpDir)
		defer func() { _ = os.Chdir(oldWd) }()

		result, err := proc.Process([]string{"./..."})
		if err != nil {
			t.Fatalf("Process failed: %v", err)
		}

		// Only main.go should be processed
		if result.FilesProcessed != 1 {
			t.Errorf("FilesProcessed = %d, want 1 (testdata should be skipped)", result.FilesProcessed)
		}
	})
}
